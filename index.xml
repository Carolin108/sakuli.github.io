<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sakuli E2E and Monitoring</title>
    <link>/</link>
    <description>Recent content on Sakuli E2E and Monitoring</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Automation</title>
      <link>/automation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/automation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Monitoring</title>
      <link>/monitoring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/monitoring/</guid>
      <description>Sometimes you want to test more than just the behaviour of your application.</description>
    </item>
    
    <item>
      <title>Monitoring Forwarder</title>
      <link>/enterprise/forwarder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/enterprise/forwarder/</guid>
      <description>End-2-End Testing &amp;amp; End-2-End Monitoring – a Perfect Combination Combining End-2-End Testing with End-2-End Monitoring proves to be optimal. Because effective quality assurance looks over and beyond any given server: Automated end-2-end tests ensure that your web or rich client application keeps its promise. Ultimately though, the users will judge the quality of your systems.
Test and monitor critical Workflows Imagine testing your critical processes and workflows (like the checkout process of your webshop that affects your conversion rate) by simulating a real user and sending the execution times, warnings and error messages to the monitoring system of your choice.</description>
    </item>
    
    <item>
      <title>Pre-Configured Headless Container</title>
      <link>/enterprise/container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/enterprise/container/</guid>
      <description>Summary Our pre-configured Docker container will run Sakuli in an isolated environment which ensures having the same setup and equal conditions for every test-run. You don´t need an unlocked display for native UI interaction with the headless VNC image configured in every container. You can watch your test execution live in a browser or a VNC client any time for debugging purposes.
Benefits:  Always rely on the same environment: no cookie hassle, no active user sessions, no artefacts of old tests Scale your tests: run multiple instances of your container in parallel to accelerate overall execution time or simulate heavy load on your application CI/CD: Easily integrate your tests into your continuous integration environment The layout and scaling of websites and native applications will always be the same and therefore increases the liability of native interactions Orchestrate, execute and alter your Test Container within the Sakuli UI portal  Architecture of Sakuli containers Each Sakuli docker image is installed with the following components:</description>
    </item>
    
    <item>
      <title>Sakuli CLI Tools</title>
      <link>/enterprise/cli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/enterprise/cli/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sakuli Hub</title>
      <link>/enterprise/hub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/enterprise/hub/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Testing</title>
      <link>/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/testing/</guid>
      <description>Sakuli makes it easy to write tests that act like a real user. It automatically sets up and starts a webdriver instance and also let you take control over the mouse and keyboard of the system.
(async () =&amp;gt; { const testCase = new TestCase(); try { await _navigateTo(&amp;#34;example.com&amp;#34;); await _setValue(_input(&amp;#39;user&amp;#39;), &amp;#39;me&amp;#39;); await _setValue(_password_(&amp;#39;password&amp;#39;), &amp;#39;top-$ecret&amp;#39;); await _click(_button(&amp;#39;Login&amp;#39;)); testCase.endOfStep(&amp;#39;Login&amp;#39;); } catch (e) { tc.handleException(e); } finally { tc.saveResult(); } }).then(done); </description>
    </item>
    
  </channel>
</rss>